const me="modulepreload",he=function(e){return"/"+e},N={},p=function(t,s,n){if(!s||s.length===0)return t();const o=document.getElementsByTagName("link");return Promise.all(s.map(r=>{if(r=he(r),r in N)return;N[r]=!0;const l=r.endsWith(".css"),i=l?'[rel="stylesheet"]':"";if(!!n)for(let $=o.length-1;$>=0;$--){const d=o[$];if(d.href===r&&(!l||d.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${r}"]${i}`))return;const a=document.createElement("link");if(a.rel=l?"stylesheet":me,l||(a.as="script",a.crossOrigin=""),a.href=r,document.head.appendChild(a),l)return new Promise(($,d)=>{a.addEventListener("load",$),a.addEventListener("error",()=>d(new Error(`Unable to preload CSS for ${r}`)))})})).then(()=>t())},ye=(e,t)=>{const s=e[t];return s?typeof s=="function"?s():Promise.resolve(s):new Promise((n,o)=>{(typeof queueMicrotask=="function"?queueMicrotask:setTimeout)(o.bind(null,new Error("Unknown variable dynamic import: "+t)))})},se="protean-elements",L={allRenderFn:!1,appendChildSlotFix:!1,asyncLoading:!0,asyncQueue:!1,attachStyles:!0,cloneNodeFix:!1,cmpDidLoad:!0,cmpDidRender:!0,cmpDidUnload:!1,cmpDidUpdate:!1,cmpShouldUpdate:!1,cmpWillLoad:!0,cmpWillRender:!1,cmpWillUpdate:!1,connectedCallback:!0,constructableCSS:!0,cssAnnotations:!0,cssVarShim:!1,devTools:!1,disconnectedCallback:!0,dynamicImportShim:!1,element:!1,event:!0,hasRenderFn:!0,hostListener:!0,hostListenerTarget:!1,hostListenerTargetBody:!1,hostListenerTargetDocument:!1,hostListenerTargetParent:!1,hostListenerTargetWindow:!1,hotModuleReplacement:!1,hydrateClientSide:!1,hydrateServerSide:!1,hydratedAttribute:!0,hydratedClass:!1,initializeNextTick:!1,invisiblePrehydration:!0,isDebug:!1,isDev:!0,isTesting:!0,lazyLoad:!0,lifecycle:!0,lifecycleDOMEvents:!0,member:!0,method:!1,mode:!1,observeAttribute:!0,profile:!1,prop:!0,propBoolean:!0,propMutable:!0,propNumber:!0,propString:!0,reflect:!0,safari10:!1,scoped:!1,scopedSlotTextContentFix:!1,scriptDataOpts:!1,shadowDelegatesFocus:!1,shadowDom:!0,shadowDomShim:!1,slot:!0,slotChildNodesFix:!1,slotRelocation:!1,state:!0,style:!0,svg:!0,taskQueue:!0,transformTagName:!1,updatable:!0,vdomAttribute:!0,vdomClass:!0,vdomFunctional:!1,vdomKey:!1,vdomListener:!0,vdomPropOrAttr:!0,vdomRef:!1,vdomRender:!0,vdomStyle:!1,vdomText:!0,vdomXlink:!0,watchCallback:!0};let I,j,f=!1,X=null,H=!1;const y=(e,t="")=>()=>{},ve=(e,t)=>()=>{},Ee="{visibility:hidden}[stencil-hydrated]{visibility:inherit}",J="http://www.w3.org/1999/xlink",Q={},Se="http://www.w3.org/2000/svg",Le="http://www.w3.org/1999/xhtml",_e=e=>e!=null,B=e=>(e=typeof e,e==="object"||e==="function"),be=(e,t,...s)=>{let n=null,o=!1,r=!1;const l=[],i=a=>{for(let $=0;$<a.length;$++)n=a[$],Array.isArray(n)?i(n):n!=null&&typeof n!="boolean"&&((o=typeof e!="function"&&!B(n))?n=String(n):typeof e!="function"&&n.$flags$===void 0&&D(`vNode passed as children has unexpected type.
Make sure it's using the correct h() function.
Empty objects can also be the cause, look for JSX comments that became objects.`),o&&r?l[l.length-1].$text$+=n:l.push(o?U(null,n):n),r=o)};if(i(s),t){e==="input"&&xe(t);{const a=t.className||t.class;a&&(t.class=typeof a!="object"?a:Object.keys(a).filter($=>a[$]).join(" "))}}l.some(C)&&D(`The <Host> must be the single root component. Make sure:
- You are NOT using hostData() and <Host> in the same component.
- <Host> is used once, and it's the single root component of the render() function.`);const c=U(e,null);return c.$attrs$=t,l.length>0&&(c.$children$=l),c},U=(e,t)=>{const s={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return s.$attrs$=null,s},Te={},C=e=>e&&e.$tag$===Te,xe=e=>{const t=Object.keys(e),s=t.indexOf("value");if(s===-1)return;const n=t.indexOf("type"),o=t.indexOf("min"),r=t.indexOf("max"),l=t.indexOf("step");(s<n||s<o||s<r||s<l)&&x('The "value" prop of <input> should be set after "min", "max", "type" and "step"')},ke=(e,t)=>e!=null&&!B(e)?t&4?e==="false"?!1:e===""||!!e:t&2?parseFloat(e):t&1?String(e):e:e,Pe=e=>E(e).$hostElement$,et=(e,t,s)=>{const n=Pe(e);return{emit:o=>(n.isConnected||x(`The "${t}" event was emitted, but the dispatcher node is no longer connected to the dom.`),q(n,t,{bubbles:!!(s&4),composed:!!(s&2),cancelable:!!(s&1),detail:o}))}},q=(e,t,s)=>{const n=u.ce(t,s);return e.dispatchEvent(n),n},Y=new WeakMap,Oe=(e,t,s)=>{let n=A.get(e);Ge&&s?(n=n||new CSSStyleSheet,typeof n=="string"?n=t:n.replaceSync(t)):n=t,A.set(e,n)},we=(e,t,s,n)=>{let o=ne(t);const r=A.get(o);if(e=e.nodeType===11?e:h,r)if(typeof r=="string"){e=e.head||e;let l=Y.get(e),i;l||Y.set(e,l=new Set),l.has(o)||(i=h.createElement("style"),i.innerHTML=r,e.insertBefore(i,e.querySelector("link")),l&&l.add(o))}else e.adoptedStyleSheets.includes(r)||(e.adoptedStyleSheets=[...e.adoptedStyleSheets,r]);return o},Ie=e=>{const t=e.$cmpMeta$,s=e.$hostElement$,n=t.$flags$,o=y("attachStyles",t.$tagName$),r=we(s.shadowRoot?s.shadowRoot:s.getRootNode(),t,e.$modeName$);n&10&&(s["s-sc"]=r,s.classList.add(r+"-h")),o()},ne=(e,t)=>"sc-"+e.$tagName$,K=(e,t,s,n,o,r)=>{if(s!==n){let l=Z(e,t),i=t.toLowerCase();if(t==="class"){const c=e.classList,a=G(s),$=G(n);c.remove(...a.filter(d=>d&&!$.includes(d))),c.add(...$.filter(d=>d&&!a.includes(d)))}else if(!l&&t[0]==="o"&&t[1]==="n")t[2]==="-"?t=t.slice(3):Z(k,i)?t=i.slice(2):t=i[2]+t.slice(3),s&&u.rel(e,t,s,!1),n&&u.ael(e,t,n,!1);else{const c=B(n);if((l||c&&n!==null)&&!o)try{if(e.tagName.includes("-"))e[t]=n;else{const $=n??"";t==="list"?l=!1:(s==null||e[t]!=$)&&(e[t]=$)}}catch{}let a=!1;i!==(i=i.replace(/^xlink\:?/,""))&&(t=i,a=!0),n==null||n===!1?(n!==!1||e.getAttribute(t)==="")&&(a?e.removeAttributeNS(J,t):e.removeAttribute(t)):(!l||r&4||o)&&!c&&(n=n===!0?"":n,a?e.setAttributeNS(J,t,n):e.setAttribute(t,n))}}},De=/\s/,G=e=>e?e.split(De):[],oe=(e,t,s,n)=>{const o=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$,r=e&&e.$attrs$||Q,l=t.$attrs$||Q;for(n in r)n in l||K(o,n,r[n],void 0,s,t.$flags$);for(n in l)K(o,n,r[n],l[n],s,t.$flags$)},W=(e,t,s,n)=>{const o=t.$children$[s];let r=0,l,i;if(o.$elm$&&D(`The JSX ${o.$text$!==null?`"${o.$text$}" text`:`"${o.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`),o.$text$!==null)l=o.$elm$=h.createTextNode(o.$text$);else{if(f||(f=o.$tag$==="svg"),l=o.$elm$=h.createElementNS(f?Se:Le,o.$tag$),f&&o.$tag$==="foreignObject"&&(f=!1),oe(null,o,f),_e(I)&&l["s-si"]!==I&&l.classList.add(l["s-si"]=I),o.$children$)for(r=0;r<o.$children$.length;++r)i=W(e,o,r),i&&l.appendChild(i);o.$tag$==="svg"?f=!1:l.tagName==="foreignObject"&&(f=!0)}return l},re=(e,t,s,n,o,r)=>{let l=e,i;for(l.shadowRoot&&l.tagName===j&&(l=l.shadowRoot);o<=r;++o)n[o]&&(i=W(null,s,o),i&&(n[o].$elm$=i,l.insertBefore(i,t)))},le=(e,t,s,n,o)=>{for(;t<=s;++t)(n=e[t])&&(o=n.$elm$,o.remove())},Ae=(e,t,s,n)=>{let o=0,r=0,l=t.length-1,i=t[0],c=t[l],a=n.length-1,$=n[0],d=n[a],g;for(;o<=l&&r<=a;)i==null?i=t[++o]:c==null?c=t[--l]:$==null?$=n[++r]:d==null?d=n[--a]:w(i,$)?(T(i,$),i=t[++o],$=n[++r]):w(c,d)?(T(c,d),c=t[--l],d=n[--a]):w(i,d)?(T(i,d),e.insertBefore(i.$elm$,c.$elm$.nextSibling),i=t[++o],d=n[--a]):w(c,$)?(T(c,$),e.insertBefore(c.$elm$,i.$elm$),c=t[--l],$=n[++r]):(g=W(t&&t[r],s,r),$=n[++r],g&&i.$elm$.parentNode.insertBefore(g,i.$elm$));o>l?re(e,n[a+1]==null?null:n[a+1].$elm$,s,n,r,a):r>a&&le(t,o,l)},w=(e,t)=>e.$tag$===t.$tag$,T=(e,t)=>{const s=t.$elm$=e.$elm$,n=e.$children$,o=t.$children$,r=t.$tag$,l=t.$text$;l===null?(f=r==="svg"?!0:r==="foreignObject"?!1:f,r==="slot"||oe(e,t,f),n!==null&&o!==null?Ae(s,n,t,o):o!==null?(e.$text$!==null&&(s.textContent=""),re(s,null,t,o,0,o.length-1)):n!==null&&le(n,0,n.length-1),f&&r==="svg"&&(f=!1)):e.$text$!==l&&(s.data=l)},je=(e,t)=>{const s=e.$hostElement$,n=e.$cmpMeta$,o=e.$vnode$||U(null,null),r=C(t)?t:be(null,null,t);if(j=s.tagName,Array.isArray(t)&&t.some(C))throw new Error(`The <Host> must be the single root component.
Looks like the render() function of "${j.toLowerCase()}" is returning an array that contains the <Host>.

The render() function should look like this instead:

render() {
  // Do not return an array
  return (
    <Host>{content}</Host>
  );
}
  `);n.$attrsToReflect$&&(r.$attrs$=r.$attrs$||{},n.$attrsToReflect$.map(([l,i])=>r.$attrs$[i]=s[l])),r.$tag$=null,r.$flags$|=4,e.$vnode$=r,r.$elm$=o.$elm$=s.shadowRoot||s,I=s["s-sc"],T(o,r)},ie=(e,t)=>{t&&!e.$onRenderResolve$&&t["s-p"]&&t["s-p"].push(new Promise(s=>e.$onRenderResolve$=s))},M=(e,t)=>{if(e.$flags$|=16,e.$flags$&4){e.$flags$|=512;return}return ie(e,e.$ancestorComponent$),Ve(()=>He(e,t))},He=(e,t)=>{const s=e.$hostElement$,n=y("scheduleUpdate",e.$cmpMeta$.$tagName$),o=e.$lazyInstance$;let r;return t?(e.$flags$|=256,e.$queuedListeners$&&(e.$queuedListeners$.map(([l,i])=>b(o,l,i)),e.$queuedListeners$=null),_(s,"componentWillLoad"),r=b(o,"componentWillLoad")):_(s,"componentWillUpdate"),_(s,"componentWillRender"),n(),Be(r,()=>Ue(e,o,t))},Ue=async(e,t,s)=>{const n=e.$hostElement$,o=y("update",e.$cmpMeta$.$tagName$),r=n["s-rc"];s&&Ie(e);const l=y("render",e.$cmpMeta$.$tagName$);e.$flags$|=1024,Ce(e,t,n),e.$renderCount$++,e.$flags$&=-1025,r&&(r.map(i=>i()),n["s-rc"]=void 0),l(),o();{const i=n["s-p"],c=()=>ze(e);i.length===0?c():(Promise.all(i).then(c),e.$flags$|=4,i.length=0)}},Ce=(e,t,s)=>{try{X=t,t=t.render&&t.render(),e.$flags$&=-17,e.$flags$|=2,(L.hasRenderFn||L.reflect)&&(L.vdomRender||L.reflect)&&(L.hydrateServerSide||je(e,t))}catch(i){S(i,e.$hostElement$)}return X=null,null},ze=e=>{const t=e.$cmpMeta$.$tagName$,s=e.$hostElement$,n=y("postUpdate",t),o=e.$lazyInstance$,r=e.$ancestorComponent$;e.$flags$|=1024,b(o,"componentDidRender"),e.$flags$&=-1025,_(s,"componentDidRender"),e.$flags$&64?(_(s,"componentDidUpdate"),n()):(e.$flags$|=64,ce(s),e.$flags$|=2048,b(o,"componentDidLoad"),e.$flags$&=-2049,_(s,"componentDidLoad"),n(),e.$onReadyResolve$(s),r||ae()),e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),e.$flags$&512&&R(()=>M(e,!1)),e.$flags$&=-517},ae=e=>{ce(h.documentElement),R(()=>q(k,"appload",{detail:{namespace:se}}))},b=(e,t,s)=>{if(e&&e[t])try{return e[t](s)}catch(n){S(n)}},Be=(e,t)=>e&&e.then?e.then(t):t(),_=(e,t)=>{q(e,"stencil_"+t,{bubbles:!0,composed:!0,detail:{namespace:se}})},ce=e=>e.setAttribute("stencil-hydrated",""),qe=(e,t)=>E(e).$instanceValues$.get(t),We=(e,t,s,n)=>{const o=E(e),r=o.$hostElement$,l=o.$instanceValues$.get(t),i=o.$flags$,c=o.$lazyInstance$;s=ke(s,n.$members$[t][0]);const a=Number.isNaN(l)&&Number.isNaN(s),$=s!==l&&!a;if((!(i&8)||l===void 0)&&$&&(o.$instanceValues$.set(t,s),o.$flags$&1024?x(`The state/prop "${t}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`,`
Element`,r,`
New value`,s,`
Old value`,l):o.$flags$&2048&&x(`The state/prop "${t}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`,`
Element`,r,`
New value`,s,`
Old value`,l),c)){if(n.$watchers$&&i&128){const d=n.$watchers$[t];d&&d.map(g=>{try{c[g](s,l,t)}catch(v){S(v,r)}})}(i&18)===2&&M(o,!1)}},$e=(e,t,s)=>{if(t.$members$){e.watchers&&(t.$watchers$=e.watchers);const n=Object.entries(t.$members$),o=e.prototype;if(n.map(([r,[l]])=>{(l&31||s&2&&l&32)&&Object.defineProperty(o,r,{get(){return qe(this,r)},set(i){{const c=E(this);!(s&1)&&!(c.$flags$&8)&&l&31&&!(l&1024)&&x(`@Prop() "${r}" on <${t.$tagName$}> is immutable but was modified from within the component.
More information: https://stenciljs.com/docs/properties#prop-mutability`)}We(this,r,i,t)},configurable:!0,enumerable:!0})}),s&1){const r=new Map;o.attributeChangedCallback=function(l,i,c){u.jmp(()=>{const a=r.get(l);if(this.hasOwnProperty(a))c=this[a],delete this[a];else if(o.hasOwnProperty(a)&&typeof this[a]=="number"&&this[a]==c)return;this[a]=c===null&&typeof this[a]=="boolean"?!1:c})},e.observedAttributes=n.filter(([l,i])=>i[0]&15).map(([l,i])=>{const c=i[1]||l;return r.set(c,l),i[0]&512&&t.$attrsToReflect$.push([l,c]),c})}}return e},Me=async(e,t,s,n,o)=>{if(!(t.$flags$&32)){{if(t.$flags$|=32,o=Qe(s,t),o.then){const c=ve(`st:load:${s.$tagName$}:${t.$modeName$}`,`[Stencil] Load module for <${s.$tagName$}>`);o=await o,c()}if(!o)throw new Error(`Constructor for "${s.$tagName$}#${t.$modeName$}" was not found`);o.isProxied||(s.$watchers$=o.watchers,$e(o,s,2),o.isProxied=!0);const i=y("createInstance",s.$tagName$);t.$flags$|=8;try{new o(t)}catch(c){S(c)}t.$flags$&=-9,t.$flags$|=128,i(),de(t.$lazyInstance$)}if(o.style){let i=o.style;const c=ne(s,t.$modeName$);if(!A.has(c)){const a=y("registerStyles",s.$tagName$);Oe(c,i,!!(s.$flags$&1)),a()}}}const r=t.$ancestorComponent$,l=()=>M(t,!0);r&&r["s-rc"]?r["s-rc"].push(l):l()},de=e=>{b(e,"connectedCallback")},Fe=e=>{if(!(u.$flags$&1)){const t=E(e),s=t.$cmpMeta$,n=y("connectedCallback",s.$tagName$);if(t.$flags$&1)ue(e,t,s.$listeners$),de(t.$lazyInstance$);else{t.$flags$|=1;{let o=e;for(;o=o.parentNode||o.host;)if(o["s-p"]){ie(t,t.$ancestorComponent$=o);break}}s.$members$&&Object.entries(s.$members$).map(([o,[r]])=>{if(r&31&&e.hasOwnProperty(o)){const l=e[o];delete e[o],e[o]=l}}),Me(e,t,s)}n()}},Re=e=>{if(!(u.$flags$&1)){const t=E(e),s=t.$lazyInstance$;t.$rmListeners$&&(t.$rmListeners$.map(n=>n()),t.$rmListeners$=void 0),b(s,"disconnectedCallback")}},tt=(e,t={})=>{const s=y(),n=[],o=t.exclude||[],r=k.customElements,l=h.head,i=l.querySelector("meta[charset]"),c=h.createElement("style"),a=[];let $,d=!0;Object.assign(u,t),u.$resourcesUrl$=new URL(t.resourcesUrl||"./",h.baseURI).href,e.map(g=>{g[1].map(v=>{const m={$flags$:v[0],$tagName$:v[1],$members$:v[2],$listeners$:v[3]};m.$members$=v[2],m.$listeners$=v[3],m.$attrsToReflect$=[],m.$watchers$={};const P=m.$tagName$,ge=class extends HTMLElement{constructor(O){super(O),O=this,Je(O,m),m.$flags$&1&&O.attachShadow({mode:"open"})}connectedCallback(){$&&(clearTimeout($),$=null),d?a.push(this):u.jmp(()=>Fe(this))}disconnectedCallback(){u.jmp(()=>Re(this))}componentOnReady(){return E(this).$onReadyPromise$}};m.$lazyBundleId$=g[0],!o.includes(P)&&!r.get(P)&&(n.push(P),r.define(P,$e(ge,m,1)))})}),c.innerHTML=n+Ee,c.setAttribute("data-styles",""),l.insertBefore(c,i?i.nextSibling:l.firstChild),d=!1,a.length?a.map(g=>g.connectedCallback()):u.jmp(()=>$=setTimeout(ae,30)),s()},ue=(e,t,s,n)=>{s&&s.map(([o,r,l])=>{const i=e,c=Ne(t,l),a=Xe(o);u.ael(i,r,c,a),(t.$rmListeners$=t.$rmListeners$||[]).push(()=>u.rel(i,r,c,a))})},Ne=(e,t)=>s=>{try{L.lazyLoad&&(e.$flags$&256?e.$lazyInstance$[t](s):(e.$queuedListeners$=e.$queuedListeners$||[]).push([t,s]))}catch(n){S(n)}},Xe=e=>Ye?{passive:(e&1)!==0,capture:(e&2)!==0}:(e&2)!==0,F=new WeakMap,E=e=>F.get(e),st=(e,t)=>F.set(t.$lazyInstance$=e,t),Je=(e,t)=>{const s={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};return s.$renderCount$=0,s.$onReadyPromise$=new Promise(n=>s.$onReadyResolve$=n),e["s-p"]=[],e["s-rc"]=[],ue(e,s,t.$listeners$),F.set(e,s)},Z=(e,t)=>t in e,S=(e,t)=>(0,console.error)(e,t),fe=["STENCIL:"],D=(...e)=>console.error(...fe,...e),x=(...e)=>console.warn(...fe,...e),V=new Map,Qe=(e,t,s)=>{const n=e.$tagName$.replace(/-/g,"_"),o=e.$lazyBundleId$;if(typeof o!="string"){D(`Trying to lazily load component <${e.$tagName$}> with style mode "${t.$modeName$}", but it does not exist.`);return}const r=V.get(o);if(r)return r[n];/*!__STENCIL_STATIC_IMPORT_SWITCH__*/return ye(Object.assign({"./protean-button.entry.js":()=>p(()=>import("./protean-button.entry-af3ef051.js"),[]),"./protean-button_11.entry.js":()=>p(()=>import("./protean-button_11.entry-22eb63db.js"),[]),"./protean-checkbox.entry.js":()=>p(()=>import("./protean-checkbox.entry-641707ff.js"),["assets/protean-checkbox.entry-641707ff.js","assets/utils-9777d7c1-a2ad5c7b.js"]),"./protean-click-elsewhere.entry.js":()=>p(()=>import("./protean-click-elsewhere.entry-68141c2f.js"),[]),"./protean-icon.entry.js":()=>p(()=>import("./protean-icon.entry-40174875.js"),[]),"./protean-input.entry.js":()=>p(()=>import("./protean-input.entry-7e51d29c.js"),["assets/protean-input.entry-7e51d29c.js","assets/utils-9777d7c1-a2ad5c7b.js"]),"./protean-message.entry.js":()=>p(()=>import("./protean-message.entry-8f26605d.js"),[]),"./protean-optgroup.entry.js":()=>p(()=>import("./protean-optgroup.entry-f4898dff.js"),["assets/protean-optgroup.entry-f4898dff.js","assets/utils-9777d7c1-a2ad5c7b.js"]),"./protean-option.entry.js":()=>p(()=>import("./protean-option.entry-2fd7afc9.js"),[]),"./protean-select.entry.js":()=>p(()=>import("./protean-select.entry-f27221c0.js"),["assets/protean-select.entry-f27221c0.js","assets/utils-9777d7c1-a2ad5c7b.js"]),"./protean-tab-container.entry.js":()=>p(()=>import("./protean-tab-container.entry-1e5a2f04.js"),["assets/protean-tab-container.entry-1e5a2f04.js","assets/utils-9777d7c1-a2ad5c7b.js"]),"./protean-tab-pane.entry.js":()=>p(()=>import("./protean-tab-pane.entry-d00c6e31.js"),[])}),`./${o}.entry.js`).then(l=>(V.set(o,l),l[n]),S)},A=new Map,k=typeof window<"u"?window:{},h=k.document||{head:{}};k.HTMLElement||class{};const u={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,s,n)=>e.addEventListener(t,s,n),rel:(e,t,s,n)=>e.removeEventListener(t,s,n),ce:(e,t)=>new CustomEvent(e,t)},Ye=(()=>{let e=!1;try{h.addEventListener("e",null,Object.defineProperty({},"passive",{get(){e=!0}}))}catch{}return e})(),Ke=e=>Promise.resolve(e),Ge=(()=>{try{return new CSSStyleSheet,typeof new CSSStyleSheet().replaceSync=="function"}catch{}return!1})(),ee=[],pe=[],Ze=(e,t)=>s=>{e.push(s),H||(H=!0,t&&u.$flags$&4?R(z):u.raf(z))},te=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(s){S(s)}e.length=0},z=()=>{te(ee),te(pe),(H=ee.length>0)&&u.raf(z)},R=e=>Ke().then(e),Ve=Ze(pe,!0);export{p as _,tt as b,et as c,Pe as g,be as h,Ke as p,st as r};
